---
title: Simulation View of Causality
author: ''
date: '2019-04-13'
slug: understanding-pearl-s-front-door-magic-part-I
categories:
  - Causality
tags:
  - front-door criterion
  - do calculus
  - causal conditioning
---
<style>
div.blue pre.r { background-color:azure; }
div.blue pre { background-color:blue; }
</style>

_I try to present an intuitive account of causal reasoning and the important notion of causal conditioning without resorting to some of the formalities of the rules of do-calculus, d-separation and the like._

First a little background to set up our running example. 

The power generated by photovoltaic solar power plants is decreased by not an insignificant amount when dirt and other particulates collect on the panels. This, so-called _soiling_ problem is especially acute in dusty desert regions which are otherwise ideal sites for solar plants, because the sun shines bright when there aren't many clouds in sight. Consequently plant operators are always on the lookout for cheap and effective panel soiling mitigation strategies.

Imagine that a meticulous solar-scientist named Sol is tasked with estimating the effect on the energy production of weekly washing of the panels in a fleet of solar power plants. Assume that he has at hand data on weekly aggregates of days of rainfall (denoted $R$), weekly average cloud-cover (denoted $C$), and total weekly energy production from the solar fleet (denoted $E$). Sol reasons that if he could estimate the effect of having _at least_ one day rainy day on energy production, he could use it as a proxy for weekly washing.

Before tackling the panel washing problem, Sol analyzes his data and constructs a _generative model_ for the data generating process. (Recall that a generative model is a story that we believe about a physical process written down in a language of probabilities.)

Commonsense tells Sol that clouds cause rain and that clouds cause a drop in energy production while rain increases production by washing away the dirt on the panels. A graphical depiction (called the _causal graph_) of Sol's mental model of the causal story hidden in the data is

![](/post/2019-04-13-understanding-pearl-s-front-door-magic_files/solar_graph.png){width=30%}

He estimates the necessary parameters of his model from the data, and implements his model as shown below to simulate behaviors or instances of the physical proess (i.e, generate joint samples of $(C, R, E)$.

<div class = "blue">
```{r}
model = function(){
  c = runif(1, min=0, max=0.3)                         ## cloud-cover: C ~ Uniform(0, 0.3)
  r = floor(7 *(4*c^2 + runif(1, min=0, max=0.1)))     ## rainy-days: R = f_R(C, noise)
  e = 500 * (1 - 2*c + 0.1 * r) + 10 * rnorm(1)        ## energy: E = f_E(c, r, noise) 
  return(data.frame(C=c, R=r, E=e))
}
```
</div>

Ignoring the particular functional forms we can notice that the order of computations follows the _topological_ order of the variables in the graph above. The average cloudiness ($C$) is a random variable, the rainy days variable ($R$) is some function of $C$ and noise, and the energy ($E$) is a function of $C$, $E$ and different noise. The noisy functions attempt to capture both measurement and modeling errors. 

Note that because of the noise variables, the above program defines a joint distribution over the triple $(C, R, E)$. In fact, Sol can compute the conditional density $P(E | R=r)$ by simply sampling from the simulator, filtering for $R=r$ and fitting a density estimator to the energy values on the filtered samples. The conditional densities look as below

```{r echo=F}
library(ggplot2)
df <- do.call(rbind, lapply(1:10000, function(i) model()))
df$R <- factor(df$R)
ggplot(aes(E, fill = R, color = R), data=df) + geom_density(alpha = 0.1)+ggtitle("P(E | R)")#+theme_bw() 
```

According to the distribution defined by the simulator the hightest energy production tends to happen in weeks with no rain. This is perhaps mildly surpising for someone who hasn't heard of _confounding_; the data shows this because both rain and energy are affected by their common cause, cloudiness. 

Sol rewrites his simulator making the noise variables explicit as well as adding some optional arguments to override some of the computations as follows

<div class = "blue">
```{r}
model = function(do_c, do_r, do_e, do_uc, do_ur, do_ue){
  uc = ifelse(missing(do_uc), runif(1), do_uc)       ## Uc ~ Uniform(0, 1)
  c = ifelse(missing(do_c), uc * 0.3, do_c)          ## C = Uc * 0.3 
  
  ur = ifelse(missing(do_ur), runif(1), do_ur)       ## Ur ~ Uniform(0, 1)
  r = ifelse(missing(do_r), 
             floor(7 *(4*c^2 + ur * 0.1)), do_r)     ## R = f_R(C, Ur)
  
  ue = ifelse(missing(do_ue), rnorm(1), do_ue)       ## Ue ~ Normal(0, 1)
  e = ifelse(missing(do_e), 
        500 * (1 - 2*c + 0.1 * r) + 10 * ue,
        do_e)                                        ## E = f_E(C, R, Ue)
  
  return(data.frame(C=c, R=r, E=e, Uc=uc, Ur=ur, Ue=ue))
}

generate = function(num_samples, ...){
  df <- do.call(rbind, lapply(1:num_samples, function(i) model(...)))
  df$R <- factor(df$R, levels=0:3)
  df
}
```
</div>

Although the code now looks much more complicated it implements exactly the same model as the version before it, albeit allowing Sol to arbitrarily set any of the variables to values of his choosing. Setting the function argument "do_x" allows Sol to surgically replace the value of variable $X$ in his simulation from what it would have been otherwise. (The "generate" function is just a helper to sample from the simulator.)

The underlying model can more clearly be depicted as 

![](/post/2019-04-13-understanding-pearl-s-front-door-magic_files/solar_graph_noise.png){width=30%}

The awesome power conferred by a simulator in one's possession brings a temptation to meddle that is hard to resist even for an old testament god, let alone a mere solar scientist. Sol dutifully proceeds to meddle.

Interventions
-------------
To determine the _causal_ effect of rain on energy production, Sol needs to simulate the process in a _parallel universe_ where rain can be controlled independently of its influence from cloudiness. (He is after all investigating the effect panel washing would have on energy production, and cloudiness would not affect the decision to wash.) He intervenes to set the rain variable to different values as follows

<div class = "blue">
```{r cache=T}
n <- 10000
#generate n samples by setting do_r to different values 0, 1, 2, 3
df <- do.call(rbind, lapply(0:3,function(r) generate(n, do_r = r)))
ggplot(aes(E, fill = R, color = R), data=df) + geom_density(alpha = 0.1)+ggtitle("P(E | do(R))")
```
</div>
The quantity $P(E|do(R=r))$ is shorthand for the distribution of $E$ produced when Sol samples from his simulator by setting the "do_r" argument to the value $r$.

Contrary to the conditional probabilities estimated before, this simulation shows that more rain _causes_ more energy. The quantity $P(E | do(R =r))$ is called the __causal conditional probability__ and is in general _different_ from the __Bayesian conditional probability__ $P(E|R=r)$.

A graphical representation of the way the process unfolds in the parallel universe (and of the program that simulates it) is

![](/post/2019-04-13-understanding-pearl-s-front-door-magic_files/solar_graph_do_r.png){width=30%}

All the arrows pointing to the node $R$ have been severed and its value is set to $r$. This is the essence of what it means to intervene -- we remove any other causal influences on the variable on which we are intervening. This is why Bayesian conditioning differs from causal conditioning -- when we causally condition, we are hypothesizing a different universe which is running a _different program_, consequently producing a _different distribution_ on the observables.

This is a good juncture to stop to rest and gaze upon the scenery. As a warmup for what is coming next the reader might want to mull the following questions.

- What is value of $P(E|do(C = c))$?
- What is interpretation of $P(E|do(R=r), C=c)$?
- What is the interpretation of $P(E|do(U_r = u_r))$?

Counterfactuals
---------------
