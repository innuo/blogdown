---
title: Simulation View of Causality
author: ''
date: '2019-04-13'
slug: understanding-pearl-s-front-door-magic-part-I
categories:
  - Causality
tags:
  - front-door criterion
  - do calculus
  - causal conditioning
---
<style>
div.blue pre.r { background-color:azure; }
div.blue pre { background-color:blue; }
</style>

_I try to present an intuitive account of causal reasoning and the important notion of causal conditioning without resorting to some of the formalities of the rules of do-calculus, d-separation and the like._

First a little background to setup our running example. 

The power generated by photovoltaic solar power plants is decreased by not an insignificant when dirt and other particulates collect on the panels. This, so-called _soiling_ problem is especially acute in dusty desert regions which are otherwise ideal sites for solar plants, because the sun shines bright when there aren't many clouds in sight. Consequently plant operators are always on the lookout for cheap and effective panel soiling mitigation strategies.

Imagine that a meticulous solar-scientist named Sol is tasked with estimating the effect on the energy production of weekly washing of the panels in a fleet of solar power plants. Assume that he has at hand data on weekly aggregates of days of rainfall (denoted $R$), weekly average cloud-cover (denoted $C$), and total weekly energy production from the solar fleet (denoted $E$). Sol reasons that if he could estimate the effect of having _at least_ one day rainy day on energy production, he could use it as a proxy for weekly washing.

Before tackling the panel washing problem, Sol analyzes his data and constructs a _generative model_ for the data generating process. (Recall that a generative model is a story that we believe about a physical process written down in a language of probabilities.)

Commonsense tells Sol that clouds cause rain and that clouds cause a drop in energy production while rain increases production by washing away the dirt on the panels. A graphical depiction (called the _causal graph_) of Sol's mental model of the causal story hidden in the data is

![](/post/2019-04-13-understanding-pearl-s-front-door-magic_files/solar_graph.png){width=30%}

He estimates the necessary parameters of his model from the data, and implements his model as shown below to simulate behaviors or instances of the physical proess (i.e, generate joint samples of $(C, R, E)$.

<div class = "blue">
```{r}
model = function(){
  c = runif(1, min=0, max=0.3)                         ## cloud-cover: C ~ Uniform(0, 0.3)
  r = floor(7 *(4*c^2 + runif(1, min=0, max=0.1)))     ## rainy-days: R = f_R(C, noise)
  e = 500 * (1 - 2*c + 0.1 * r) + 10 * rnorm(1)        ## energy: E = f_E(c, r, noise) 
  return(data.frame(C=c, R=r, E=e))
}
```
</div>

Ignoring the particular functional forms we can notice that the order of computations follows the _topological_ order of the variables in the graph above. The average cloudiness ($C$) is a random variable, the rainy days variable ($R$) is some function of $C$ and noise, and the energy ($E$) is a function of $C$, $E$ and different noise. The noisy functions attempt to capture both measurement and modeling errors. 

Note that because of the noise variables, the above program defines a joint distribution over the triple $(C, R, E)$. In fact, Sol can compute the conditional density $P(E | R=r)$ by simply sampling from the simulator, filtering for $R=r$ and fitting a density estimator to the energy values on the filtered samples. The conditional densities look as below

```{r echo=F}
library(ggplot2)
df <- do.call(rbind, lapply(1:10000, function(i) model()))
df$R <- factor(df$R)
ggplot(aes(E, fill = R, color = R), data=df) + geom_density(alpha = 0.1)+ggtitle("P(E|R=r)")#+theme_bw() 
```
According to the distribution defined by the simulator the hightest energy production tends to happen in weeks with no rain. This is perhaps mildly surpising for someone who hasn't heard of _confounding_; the data shows this because both rain and energy are affected by their common cause, cloudiness. 

Sol rewrites his simulator making the noise variables explicit as well as adding some optional arguments to override some of the computations as follows

<div class = "blue">
```{r}
model = function(do_c, do_r, do_e, do_uc, do_ur, do_ue){
  uc = ifelse(missing(do_uc), runif(1), do_uc)       ## Uc ~ Uniform(0, 1)
  c = ifelse(missing(do_c), uc * 0.3, do_c)          ## C = Uc * 0.3 
  
  ur = ifelse(missing(do_ur), runif(1), do_ur)       ## Ur ~ Uniform(0, 1)
  r = ifelse(missing(do_r), 
             floor(7 *(4*c^2 + ur * 0.1)), do_r)     ## R = f_R(C, Ur)
  
  ue = ifelse(missing(do_ue), rnorm(1), do_ue)       ## Ue ~ Normal(0, 1)
  e = ifelse(missing(do_e), 
        500 * (1 - 2*c + 0.1 * r) + 10 * ue,
        do_e)                                        ## E = f_E(C, R, Ue)
  
  return(data.frame(C=c, R=r, E=e, Uc=uc, Ur=ur, Ue=ue))
}
```
</div>

Although the code now looks much more complicated it implements exactly the same model as the version before it, albeit allowing Sol to arbitrarily set any of the variables to values of his choice.

![](/post/2019-04-13-understanding-pearl-s-front-door-magic_files/solar_graph_noise.png){width=30%}


