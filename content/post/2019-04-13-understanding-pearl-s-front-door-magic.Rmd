---
title: Simulation View of Causality
author: ''
date: '2019-04-13'
slug: understanding-pearl-s-front-door-magic-part-I
categories:
  - Causality
tags:
  - front-door criterion
  - do calculus
  - causal conditioning
---
<style>
div.blue pre.r { background-color:azure; }
div.blue pre { background-color:blue; }
</style>

_I try to present an intuitive account of causal reasoning and the important notion of causal conditioning without resorting to some of the formalities of the rules of do-calculus, d-separation and the like._

First a little background to setup our running example. 

The power generated by photovoltaic solar power plants is decreased by not an insignificant when dirt and other particulates collect on the panels. This, so-called _soiling_ problem is especially acute in dusty desert regions which are otherwise ideal sites for solar plants, because the sun shines bright when there aren't many clouds in sight. Consequently plant operators are always on the lookout for cheap and effective panel soiling mitigation strategies.

Imagine a meticulous solar-scientist Sol who is tasked with estimating the effect on the energy production of weekly washing of the panels in a fleet of solar power plants. Assume that he has at hand data on weekly aggregates of days of rainfall (denoted $R$), weekly average cloud-cover (denoted $C$), and total weekly energy production from the solar fleet (denoted $E$). Sol reasons that if he could estimate the effect of having _at least_ one day rainy day on energy production, he could use it as a proxy for weekly washing.

Before tackling the panel washing problem, Sol analyzes his data builds a _generative model_ for the data generating process. (Recall that a generative model is a story that we believe about a physical process written down in a language of probabilities.)

Sol implements his model as shown below to simulate behaviors or instances of the physical proess (i.e, generate joint samples of $(C, R, E)$).

<div class = "blue">
```{r}
model <- function(){
  c = runif(1, min=0, max=0.3)                         ## cloud-cover: C ~ Uniform(0, 0.3)
  r = floor(7 *(4*c^2 + runif(1, min=0, max=0.1)))     ## rainy-days: R = f_R(C, noise)
  e = 500 * (1 - 2*c + 0.1 * r) + 10 * rnorm(1)        ## energy: E = f_E(c, r, noise) 
  return(data.frame(C=c, R=r, E=e))
}
```
</div>

Notice how the average cloudiness ($C$) is a random variable, rainy days variable ($R$) is a function of $C$ and noise, and the energy ($E$) is a function of $C$, $E$ and different noise The order of computations in the simulator can be depicted as 

![](/post/2019-04-13-understanding-pearl-s-front-door-magic_files/solar_graph.png){width=30%}

Sol rewrites his simulator making the noise variables explicit as well as adding some optional arguments to circumvent some of the computations as follows

<div class = "blue">
```{r}
model <- function(do_c, do_r, do_e, do_uc, do_ur, do_ue){
  uc = ifelse(missing(do_uc), runif(1), do_uc)      # Uc ~ Uniform(0, 1)
  c = ifelse(missing(do_c), uc * 0.3, do_c)          # C = Uc * 0.3 
  
  ur = ifelse(missing(do_ur), runif(1), do_ur)       # Ur ~ Uniform(0, 1)
  r = ifelse(missing(do_r), 
             floor(7 *(4*c^2 + ur * 0.1)), do_r)     # R = f_R(C, Ur)
  
  ue = ifelse(missing(do_ue), rnorm(1), do_ue)       # Ue ~ Normal(0, 1)
  e = ifelse(missing(do_e), 
        500 * (1 - 2*c + 0.1 * r) + 10 * ue,
        do_e)                                        # E = f_E(C, R, Ue)
  
  return(data.frame(C=c, R=r, E=e, Uc=uc, Ur=ur, Ue=ue))
}
```
</div>

Although the code now looks much more complicated it implements exactly the same model as the version before it, albeit allowing arbitrarily setting the the variables to Sol chooses.

![](/post/2019-04-13-understanding-pearl-s-front-door-magic_files/solar_graph_noise.png){width=30%}
