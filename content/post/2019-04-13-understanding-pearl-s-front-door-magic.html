---
title: Simulation View of Causality
author: ''
date: '2019-04-13'
slug: understanding-pearl-s-front-door-magic-part-I
categories:
  - Causality
tags:
  - front-door criterion
  - do calculus
  - causal conditioning
---



<style>
div.blue pre.r { background-color:azure; }
div.blue pre { background-color:blue; }
</style>
<p><em>I try to present an intuitive account of causal reasoning and the important notion of causal conditioning without resorting to some of the formalities of the rules of do-calculus, d-separation and the like.</em></p>
<p>First a little background to setup our running example.</p>
<p>The power generated by photovoltaic solar power plants is decreased by not an insignificant when dirt and other particulates collect on the panels. This, so-called <em>soiling</em> problem is especially acute in dusty desert regions which are otherwise ideal sites for solar plants, because the sun shines bright when there aren’t many clouds in sight. Consequently plant operators are always on the lookout for cheap and effective panel soiling mitigation strategies.</p>
<p>Imagine that a meticulous solar-scientist named Sol is tasked with estimating the effect on the energy production of weekly washing of the panels in a fleet of solar power plants. Assume that he has at hand data on weekly aggregates of days of rainfall (denoted <span class="math inline">\(R\)</span>), weekly average cloud-cover (denoted <span class="math inline">\(C\)</span>), and total weekly energy production from the solar fleet (denoted <span class="math inline">\(E\)</span>). Sol reasons that if he could estimate the effect of having <em>at least</em> one day rainy day on energy production, he could use it as a proxy for weekly washing.</p>
<p>Before tackling the panel washing problem, Sol analyzes his data and constructs a <em>generative model</em> for the data generating process. (Recall that a generative model is a story that we believe about a physical process written down in a language of probabilities.)</p>
<p>Commonsense tells Sol that clouds cause rain and that clouds cause a drop in energy production while rain increases production by washing away the dirt on the panels. A graphical depiction (called the <em>causal graph</em>) of Sol’s mental model of the causal story hidden in the data is</p>
<p><img src="/post/2019-04-13-understanding-pearl-s-front-door-magic_files/solar_graph.png" style="width:30.0%" /></p>
<p>He estimates the necessary parameters of his model from the data, and implements his model as shown below to simulate behaviors or instances of the physical proess (i.e, generate joint samples of <span class="math inline">\((C, R, E)\)</span>.</p>
<div class="blue">
<pre class="r"><code>model = function(){
  c = runif(1, min=0, max=0.3)                         ## cloud-cover: C ~ Uniform(0, 0.3)
  r = floor(7 *(4*c^2 + runif(1, min=0, max=0.1)))     ## rainy-days: R = f_R(C, noise)
  e = 500 * (1 - 2*c + 0.1 * r) + 10 * rnorm(1)        ## energy: E = f_E(c, r, noise) 
  return(data.frame(C=c, R=r, E=e))
}</code></pre>
</div>
<p>Ignoring the particular functional forms we can notice that the order of computations follows the <em>topological</em> order of the variables in the graph above. The average cloudiness (<span class="math inline">\(C\)</span>) is a random variable, the rainy days variable (<span class="math inline">\(R\)</span>) is some function of <span class="math inline">\(C\)</span> and noise, and the energy (<span class="math inline">\(E\)</span>) is a function of <span class="math inline">\(C\)</span>, <span class="math inline">\(E\)</span> and different noise. The noisy functions attempt to capture both measurement and modeling errors.</p>
<p>Note that because of the noise variables, the above program defines a joint distribution over the triple <span class="math inline">\((C, R, E)\)</span>. In fact, Sol can compute the conditional density <span class="math inline">\(P(E | R=r)\)</span> by simply sampling from the simulator, filtering for <span class="math inline">\(R=r\)</span> and fitting a density estimator to the energy values on the filtered samples. The conditional densities look as below</p>
<p><img src="/post/2019-04-13-understanding-pearl-s-front-door-magic_files/figure-html/unnamed-chunk-2-1.png" width="672" />
According to the distribution defined by the simulator the hightest energy production tends to happen in weeks with no rain. This is perhaps mildly surpising for someone who hasn’t heard of <em>confounding</em>; the data shows this because both rain and energy are affected by their common cause, cloudiness.</p>
<p>Sol rewrites his simulator making the noise variables explicit as well as adding some optional arguments to override some of the computations as follows</p>
<div class="blue">
<pre class="r"><code>model = function(do_c, do_r, do_e, do_uc, do_ur, do_ue){
  uc = ifelse(missing(do_uc), runif(1), do_uc)       ## Uc ~ Uniform(0, 1)
  c = ifelse(missing(do_c), uc * 0.3, do_c)          ## C = Uc * 0.3 
  
  ur = ifelse(missing(do_ur), runif(1), do_ur)       ## Ur ~ Uniform(0, 1)
  r = ifelse(missing(do_r), 
             floor(7 *(4*c^2 + ur * 0.1)), do_r)     ## R = f_R(C, Ur)
  
  ue = ifelse(missing(do_ue), rnorm(1), do_ue)       ## Ue ~ Normal(0, 1)
  e = ifelse(missing(do_e), 
        500 * (1 - 2*c + 0.1 * r) + 10 * ue,
        do_e)                                        ## E = f_E(C, R, Ue)
  
  return(data.frame(C=c, R=r, E=e, Uc=uc, Ur=ur, Ue=ue))
}</code></pre>
</div>
<p>Although the code now looks much more complicated it implements exactly the same model as the version before it, albeit allowing Sol to arbitrarily set any of the variables to values of his choice.</p>
<p><img src="/post/2019-04-13-understanding-pearl-s-front-door-magic_files/solar_graph_noise.png" style="width:30.0%" /></p>
