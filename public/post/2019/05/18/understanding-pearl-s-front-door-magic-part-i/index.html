<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Simulation View of Causality | Notes To An Earlier Self</title>
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    
  </head>

  <body>
    <nav>
    <ul class="menu">
      
      <li><a href="/">Home</a></li>
      
      <li><a href="/about/">About</a></li>
      
      <li><a href="/categories/">Categories</a></li>
      
      <li><a href="/tags/">Tags</a></li>
      
    </ul>
    <hr/>
    </nav>

<div class="article-meta">
<h1><span class="title">Simulation View of Causality</span></h1>

<h2 class="date">2019/05/18</h2>
</div>

<main>



<style>
div.blue pre.r { background-color:azure; }
div.blue pre { background-color:#ffe2dd; }
</style>
<p><em>My attempt to present an intuitive account of causal reasoning and the important notions of causal conditioning and counterfactuals without resorting to some of the formalities of do-calculus, d-separation, couterfactual notation and the like. All the programs in the post will be in R, but should be accessible to readers with no experience with the language.</em></p>
<p>Causal reasoning from scientific data has undergone a quiet revolution in the past couple of decades. The fundamentals of the newly clarified concepts and algorithmic frameworks for systematically answering causal questions are simple and ought to be more widely known than they are. There are several excellent expositions on the topic (some references at the bottom of the post), but perhaps another one won’t be unwelcome.</p>
<p>I will use a running example accompanied by simple programs in R to illustrate the concepts. First a little background to set up our example.</p>
<p>The amount of energy generated by photovoltaic solar power-plants is decreased by not an insignificant amount when dirt and other particulates collect on the panels. This, so-called <em>soiling</em> problem is especially acute in dusty desert regions which are otherwise ideal sites for solar plants, because the sun shines bright when there aren’t many clouds in sight. Consequently plant operators are always on the lookout for cheap and effective panel soiling mitigation strategies.</p>
<p>Imagine that a meticulous solar-scientist named Sol is tasked with estimating the effect on the energy production of weekly washing of the panels in a fleet of solar power plants. Assume that he has at hand data on weekly aggregates of days of rainfall (denoted <span class="math inline">\(R\)</span>), weekly average cloud-cover (denoted <span class="math inline">\(C\)</span>), and total weekly energy production from the solar fleet (denoted <span class="math inline">\(E\)</span>). Sol reasons that if he could estimate the effect of having <em>at least</em> one day of rain on the amount of energy produced, he could use it as a proxy for weekly washing.</p>
<p>Before tackling the panel washing problem, Sol analyzes his data and incorporates known physical principles to construct a <em>generative model</em> for the data generating process. (Recall that a generative model is a story that we believe about a physical process written down in the language of probabilities.)</p>
<p>Commonsense tells Sol that clouds cause rain and that clouds cause a drop in energy production, while rain increases production by washing away the dirt on the panels. A graphical depiction (called the <em>causal graph</em>) of Sol’s mental model of the causal story hidden in the data is</p>
<p><img src="/post/2019-04-13-understanding-pearl-s-front-door-magic_files/solar_graph.png" style="width:30.0%" /></p>
<p>He estimates the necessary parameters of his model from the data, and implements his model as shown below to simulate behaviors or instances of the physical proess (i.e, generate joint samples of <span class="math inline">\((C, R, E)\)</span>.</p>
<div class="blue">
<pre class="r"><code>model = function(){
  c = runif(1, min=0, max=0.3)                         ## cloud-cover: C ~ Uniform(0, 0.3)
  r = floor(7 *(4*c^2 + runif(1, min=0, max=0.1)))     ## rainy-days: R = f_R(C, noise)
  e = 500 * (1 - 2*c + 0.1 * r) + 10 * rnorm(1)        ## energy: E = f_E(c, r, noise) 
  return(data.frame(C=c, R=r, E=e))
}</code></pre>
</div>
<p>Because the causal graph is a depiction of the sequential computation of the variables it <em>must</em> be a Directed Acyclic Graph (DAG) which defines a <em>partial order</em> on the variables.</p>
<p>Ignoring the particular functional forms we can notice that the order of computations follows the <em>topological</em> order of the variables in the graph above. The average cloudiness (<span class="math inline">\(C\)</span>) is a random variable, the rainy days variable (<span class="math inline">\(R\)</span>) is some function of <span class="math inline">\(C\)</span> and noise, and the energy (<span class="math inline">\(E\)</span>) is a function of <span class="math inline">\(C\)</span>, <span class="math inline">\(E\)</span> and different noise. The noisy functions attempt to capture both measurement and modeling errors.</p>
<p>Note that because of the noise variables, the above program defines a joint distribution over the triple <span class="math inline">\((C, R, E)\)</span>. In fact, Sol can compute the conditional density <span class="math inline">\(P(E | R=r)\)</span> by simply sampling from the simulator, filtering for <span class="math inline">\(R=r\)</span> and fitting a density estimator to the energy values on the filtered samples. The conditional densities look as below</p>
<p><img src="/post/2019-04-13-understanding-pearl-s-front-door-magic_files/figure-html/unnamed-chunk-2-1.png" width="672" /></p>
<p>According to the distribution defined by the simulator the hightest energy production tends to happen in weeks with no rain. This is perhaps mildly surpising for someone who hasn’t heard of <em>confounding</em>; the data shows this because both rain and energy are affected by their common cause – cloudiness.</p>
<p>Sol rewrites his simulator making the noise variables explicit as well as adding some optional arguments to override some of the computations as follows</p>
<div class="blue">
<pre class="r"><code>model = function(do_c, do_r, do_e, do_uc, do_ur, do_ue){
  uc = ifelse(missing(do_uc), runif(1), do_uc)       ## Uc ~ Uniform(0, 1)
  c = ifelse(missing(do_c), uc * 0.3, do_c)          ## C = Uc * 0.3 
  
  ur = ifelse(missing(do_ur), runif(1), do_ur)       ## Ur ~ Uniform(0, 1)
  r = ifelse(missing(do_r), 
             floor(7 *(4*c^2 + ur * 0.1)), do_r)     ## R = f_R(C, Ur)
  
  ue = ifelse(missing(do_ue), rnorm(1), do_ue)       ## Ue ~ Normal(0, 1)
  e = ifelse(missing(do_e), 
        500 * (1 - 2*c + 0.1 * r) + 10 * ue,
        do_e)                                        ## E = f_E(C, R, Ue)
  
  return(data.frame(C=c, R=r, E=e, UC=uc, UR=ur, UE=ue))
}

generate = function(num_samples, ...){
  df &lt;- do.call(rbind, lapply(1:num_samples, function(i) model(...)))
  df$R &lt;- factor(df$R, levels=0:3)
  df
}</code></pre>
</div>
<p>Although the code now looks more complicated it implements exactly the same model as the version before it, albeit allowing Sol to arbitrarily set any of the variables to values of his choosing. Setting the function argument “do_x” allows Sol to surgically replace the value of variable <span class="math inline">\(X\)</span> in his simulation from what it would have been otherwise. (The “generate” function is just a helper to sample from the simulator.)</p>
<p>The underlying model can more clearly be depicted as</p>
<p><img src="/post/2019-04-13-understanding-pearl-s-front-door-magic_files/solar_graph_noise.png" style="width:30.0%" /></p>
<p>The randomness in the simulator is owed only to the <em>indepdendent</em> noise variables <span class="math inline">\(U_C\)</span>, <span class="math inline">\(U_R\)</span> and <span class="math inline">\(U_E\)</span>; the variables <span class="math inline">\(C\)</span>, <span class="math inline">\(R\)</span> and <span class="math inline">\(E\)</span> are <em>deterministic</em> functions of the variables they <em>listen to</em> (to borrow a phrase that Judea Pearl populalized). We can think of the values taken by the noise variables <span class="math inline">\(U_C\)</span>, <span class="math inline">\(U_R\)</span> and <span class="math inline">\(U_E\)</span> for any sample as <em>defining</em> that sample. They give the sample its <em>individuality</em> as it were.</p>
<p>A model with this structure is termed a <em>Structural Causal Model</em>, which I only mention to prime you to its encounter in future wanderings.</p>
<p>The awesome power conferred by a simulator in one’s possession brings a temptation to meddle that is hard to resist even for an old testament god, let alone a mere solar scientist. Sol dutifully proceeds to meddle.</p>
<div id="interventions" class="section level2">
<h2>Interventions</h2>
<p>To determine the <em>causal</em> effect of rain on energy production, Sol needs to simulate the process in a <em>parallel universe</em> where rain can be controlled independently of its influence from cloudiness. (He is after all investigating the effect panel washing would have on energy production, and cloudiness would not affect the decision to wash.) He intervenes to set the rain variable to different values as follows</p>
<div class="blue">
<pre class="r"><code>n &lt;- 10000
## generate n samples each by setting do_r to different values 0, 1, 2, or 3
df_intervention &lt;- do.call(rbind, lapply(0:3,function(r) generate(n, do_r = r)))
ggplot(aes(E, fill = R, color = R), data=df_intervention) + geom_density(alpha = 0.1)+ggtitle(&quot;P(E | do(R))&quot;)</code></pre>
<p><img src="/post/2019-04-13-understanding-pearl-s-front-door-magic_files/figure-html/unnamed-chunk-4-1.png" width="672" /></p>
</div>
<p>The quantity <span class="math inline">\(P(E|do(R=r))\)</span> is shorthand for the distribution of <span class="math inline">\(E\)</span> produced when Sol samples from his simulator by setting the “do_r” argument to the value <span class="math inline">\(r\)</span>.</p>
<p>Contrary to the conditional probabilities estimated before, this simulation shows that more rain <em>causes</em> more energy. The so-called <strong>interventional distribution</strong> <span class="math inline">\(P(E | do(R =r))\)</span> is obtained by <strong>causal conditioning</strong> and is in general <em>different</em> from the <strong>Bayesian conditional distribution</strong> <span class="math inline">\(P(E|R=r)\)</span>.</p>
<p>A graphical representation of the way the process unfolds in the parallel universe (and of the program that simulates it) is</p>
<p><img src="/post/2019-04-13-understanding-pearl-s-front-door-magic_files/solar_graph_do_r.png" style="width:30.0%" /></p>
<p>All the arrows pointing to the node <span class="math inline">\(R\)</span> have been severed and its value is set to <span class="math inline">\(r\)</span>. This is the essence of what it means to intervene – we remove any other causal influences on the variable on which we are intervening. This is why Bayesian conditioning differs from causal conditioning – when we causally condition, we are hypothesizing a different universe which is running a <em>different program</em>, consequently producing a <em>different distribution</em> over the observables.</p>
<p>One way to internalize the conceptual difference between the two kinds of conditioning is to note that causal conditioning is carried out by setting the “do” argument of the simulator, whereas Bayesian conditioning is carried out by sampling and filtering. For example, to estimate <span class="math inline">\(P(E | do(R =r), C=c)\)</span> we sample from the simulator by setting argument do_r to <span class="math inline">\(r\)</span>, then filter the generated samples for <span class="math inline">\(C =c\)</span> and compute the histogram over <span class="math inline">\(E\)</span> from the filtered samples.</p>
<p>So, what <em>is</em> the distribution of <span class="math inline">\(E\)</span> given <span class="math inline">\(do(R=r)\)</span>? First note that the joint probability <span class="math inline">\(P(E, C|do(R=r))\)</span> can be computed as</p>
<p><span class="math display">\[\begin{align}
P(E, C=c|do(R=r)) &amp;= P(E|C=c, do(R=r)) P(C=c) \\
&amp;= P(E|C=c, R=r) P(C=c) \\
\end{align}\]</span></p>
<p>The first equality stems from how <span class="math inline">\(E\)</span> is generated by the simulator – first generate <span class="math inline">\(C\)</span> according its marginal probability and then generate <span class="math inline">\(E\)</span> from <span class="math inline">\(C\)</span> and the “intervened” value of <span class="math inline">\(R\)</span>. The second equality results from the fact that if <span class="math inline">\(C\)</span> were fixed, it does not matter whether <span class="math inline">\(R=r\)</span> results “naturally” or from being intervened on.</p>
<p>Therefore
<span class="math display">\[P(E|do(R =r)) = \sum_c P(E, C=c|do(R=r)) = \sum_c P(E|C=c, R=r) P(C=c)\]</span>
This result is an instance of something called the <em>backdoor formula</em> about which I will have more to say in my next post. For now just notice how an expression for causal conditioning (with a “do”) was translated into an expression containing only Bayesian conditioning (without any “do”s).</p>
<p>Now might be a good juncture to break for rest and to take in the scenery. As a warmup for what is coming next you might want to mull the following questions. Looking at the order of the calculations in Sol’s simulator above may help.</p>
<ul>
<li>What is <span class="math inline">\(P(E | do(R=r), do(U_R=u_r))\)</span>?</li>
<li>How does <span class="math inline">\(P(E|do(C = c))\)</span> relate <span class="math inline">\(P(E|C=c)\)</span>?</li>
<li>What is the interpretation of <span class="math inline">\(P(E|do(U_R = u_r))\)</span>?</li>
</ul>
</div>
<div id="counterfactuals" class="section level2">
<h2>Counterfactuals</h2>
<p>As noted above for any one sample from the model, the particular values assumed by the random variables <span class="math inline">\(U_C\)</span>, <span class="math inline">\(U_R\)</span> and <span class="math inline">\(U_E\)</span> for that sample completely specify it, and together represent a particular week in our universe. In other words, we can <em>define</em> an individual week by <em>assigning</em> specific values to these random variables.</p>
<p>Let us generate a <em>single</em> sample from, Sol’s simulator.</p>
<div class = "blue">

<pre class="r"><code>set.seed(0)
week_a = generate(1)                     ## generate one sample
kable(week_a, format=&quot;html&quot;, digits = 2) ## print the sample</code></pre>
<table>
<thead>
<tr>
<th style="text-align:right;">
C
</th>
<th style="text-align:left;">
R
</th>
<th style="text-align:right;">
E
</th>
<th style="text-align:right;">
UC
</th>
<th style="text-align:right;">
UR
</th>
<th style="text-align:right;">
UE
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right;">
0.27
</td>
<td style="text-align:left;">
2
</td>
<td style="text-align:right;">
327.73
</td>
<td style="text-align:right;">
0.9
</td>
<td style="text-align:right;">
0.27
</td>
<td style="text-align:right;">
-0.33
</td>
</tr>
</tbody>
</table>
</div>
<p>We can now ask the following question. <em>What would the energy prodcution have been in this week had it not rained at all?</em> This is what we call a <em>counterfactual</em>; a question about events in a universe where they unfolded contrary to those in our actual factual universe.</p>
<p>What does this counterfactual question mean? Colloquially it means, “<em>all else being equal</em> how would the energy production <span class="math inline">\(E\)</span> have changed to if we had set <span class="math inline">\(R\)</span> to zero?”. Clearly the “all else” does not include <span class="math inline">\(E\)</span> itself. We only mean that while not changing anything that gives this week its <em>individuality</em> how does intervening on <span class="math inline">\(R\)</span> affect <span class="math inline">\(E\)</span>.</p>
<p>As we said before, an instance derives its individuality from the values assumed by the noise variables <span class="math inline">\(U_C\)</span>, <span class="math inline">\(U_R\)</span> and <span class="math inline">\(U_E\)</span>. Therefore the way to answer the counterfactual is to run the simulator with the arguments do_uc, do_ur, do_ue set to 0.9, 0.27, and -0.33 respectively <em>and</em> to set do_r to 0.</p>
<div class = "blue">

<pre class="r"><code>counterfactual_week_a = generate(1, do_uc=0.9, do_ur=0.27, do_ue=-0.33, do_r=0)    ## counterfactual!
kable(counterfactual_week_a, format=&quot;html&quot;, digits = 2) </code></pre>
<table>
<thead>
<tr>
<th style="text-align:right;">
C
</th>
<th style="text-align:left;">
R
</th>
<th style="text-align:right;">
E
</th>
<th style="text-align:right;">
UC
</th>
<th style="text-align:right;">
UR
</th>
<th style="text-align:right;">
UE
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right;">
0.27
</td>
<td style="text-align:left;">
0
</td>
<td style="text-align:right;">
226.7
</td>
<td style="text-align:right;">
0.9
</td>
<td style="text-align:right;">
0.27
</td>
<td style="text-align:right;">
-0.33
</td>
</tr>
</tbody>
</table>
</div>
<p>We estimate that the energy production <em>would have been</em> 227 Mwh ((instead of the 328 Mwh that was <em>actually observed</em>) had it not rained <em>in that particular week</em>. Note that because all the noise variables are fixed there is no stochasticity left in the simulator – it would produce exactly the same vector of observations no matter how many times we run it.</p>
<p>We can perform this <span class="math inline">\(do(R=0)\)</span> counterfactual computation for every instance in our universe. Because of the lack of stochasticity in counterfactual sample, there is a one-to-one correspondence between every example in the factual universe and those in the counterfactual universe.</p>
<p>I will annotate the column names of the counterfactual samples by a subscript “r” (or &quot;_r&quot; in the column names) to indicate that these measurements are made in the parallel universe where <span class="math inline">\(R\)</span> was intervened on.</p>
<div class = "blue">

<pre class="r"><code>n = 10000
weeks_actual = generate(n) 
weeks_counterfactual = do.call(rbind, lapply(1:n,function(i) 
           generate(1, do_uc=weeks_actual$UC[i], do_ur=weeks_actual$UR[i], do_ue=weeks_actual$UE[i], do_r=0)))
names(weeks_counterfactual) = paste0(names(weeks_counterfactual), &quot;_r&quot;) ## rename counterfactual variables
df_counterfactual = cbind(weeks_actual,weeks_counterfactual)
kable(df_counterfactual[1:10,], format=&quot;html&quot;, digits = 2) </code></pre>
<table>
<thead>
<tr>
<th style="text-align:right;">
C
</th>
<th style="text-align:left;">
R
</th>
<th style="text-align:right;">
E
</th>
<th style="text-align:right;">
UC
</th>
<th style="text-align:right;">
UR
</th>
<th style="text-align:right;">
UE
</th>
<th style="text-align:right;">
C_r
</th>
<th style="text-align:left;">
R_r
</th>
<th style="text-align:right;">
E_r
</th>
<th style="text-align:right;">
UC_r
</th>
<th style="text-align:right;">
UR_r
</th>
<th style="text-align:right;">
UE_r
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right;">
0.27
</td>
<td style="text-align:left;">
2
</td>
<td style="text-align:right;">
340.26
</td>
<td style="text-align:right;">
0.91
</td>
<td style="text-align:right;">
0.20
</td>
<td style="text-align:right;">
1.27
</td>
<td style="text-align:right;">
0.27
</td>
<td style="text-align:left;">
0
</td>
<td style="text-align:right;">
240.26
</td>
<td style="text-align:right;">
0.91
</td>
<td style="text-align:right;">
0.20
</td>
<td style="text-align:right;">
1.27
</td>
</tr>
<tr>
<td style="text-align:right;">
0.20
</td>
<td style="text-align:left;">
1
</td>
<td style="text-align:right;">
336.36
</td>
<td style="text-align:right;">
0.66
</td>
<td style="text-align:right;">
0.63
</td>
<td style="text-align:right;">
-1.54
</td>
<td style="text-align:right;">
0.20
</td>
<td style="text-align:left;">
0
</td>
<td style="text-align:right;">
286.36
</td>
<td style="text-align:right;">
0.66
</td>
<td style="text-align:right;">
0.63
</td>
<td style="text-align:right;">
-1.54
</td>
</tr>
<tr>
<td style="text-align:right;">
0.05
</td>
<td style="text-align:left;">
0
</td>
<td style="text-align:right;">
444.09
</td>
<td style="text-align:right;">
0.18
</td>
<td style="text-align:right;">
0.69
</td>
<td style="text-align:right;">
-0.29
</td>
<td style="text-align:right;">
0.05
</td>
<td style="text-align:left;">
0
</td>
<td style="text-align:right;">
444.09
</td>
<td style="text-align:right;">
0.18
</td>
<td style="text-align:right;">
0.69
</td>
<td style="text-align:right;">
-0.29
</td>
</tr>
<tr>
<td style="text-align:right;">
0.15
</td>
<td style="text-align:left;">
1
</td>
<td style="text-align:right;">
424.74
</td>
<td style="text-align:right;">
0.50
</td>
<td style="text-align:right;">
0.72
</td>
<td style="text-align:right;">
2.40
</td>
<td style="text-align:right;">
0.15
</td>
<td style="text-align:left;">
0
</td>
<td style="text-align:right;">
374.74
</td>
<td style="text-align:right;">
0.50
</td>
<td style="text-align:right;">
0.72
</td>
<td style="text-align:right;">
2.40
</td>
</tr>
<tr>
<td style="text-align:right;">
0.23
</td>
<td style="text-align:left;">
2
</td>
<td style="text-align:right;">
358.78
</td>
<td style="text-align:right;">
0.78
</td>
<td style="text-align:right;">
0.93
</td>
<td style="text-align:right;">
-0.80
</td>
<td style="text-align:right;">
0.23
</td>
<td style="text-align:left;">
0
</td>
<td style="text-align:right;">
258.78
</td>
<td style="text-align:right;">
0.78
</td>
<td style="text-align:right;">
0.93
</td>
<td style="text-align:right;">
-0.80
</td>
</tr>
<tr>
<td style="text-align:right;">
0.04
</td>
<td style="text-align:left;">
0
</td>
<td style="text-align:right;">
459.44
</td>
<td style="text-align:right;">
0.13
</td>
<td style="text-align:right;">
0.27
</td>
<td style="text-align:right;">
-0.29
</td>
<td style="text-align:right;">
0.04
</td>
<td style="text-align:left;">
0
</td>
<td style="text-align:right;">
459.44
</td>
<td style="text-align:right;">
0.13
</td>
<td style="text-align:right;">
0.27
</td>
<td style="text-align:right;">
-0.29
</td>
</tr>
<tr>
<td style="text-align:right;">
0.11
</td>
<td style="text-align:left;">
0
</td>
<td style="text-align:right;">
381.17
</td>
<td style="text-align:right;">
0.38
</td>
<td style="text-align:right;">
0.87
</td>
<td style="text-align:right;">
-0.41
</td>
<td style="text-align:right;">
0.11
</td>
<td style="text-align:left;">
0
</td>
<td style="text-align:right;">
381.17
</td>
<td style="text-align:right;">
0.38
</td>
<td style="text-align:right;">
0.87
</td>
<td style="text-align:right;">
-0.41
</td>
</tr>
<tr>
<td style="text-align:right;">
0.18
</td>
<td style="text-align:left;">
1
</td>
<td style="text-align:right;">
361.21
</td>
<td style="text-align:right;">
0.60
</td>
<td style="text-align:right;">
0.49
</td>
<td style="text-align:right;">
-0.89
</td>
<td style="text-align:right;">
0.18
</td>
<td style="text-align:left;">
0
</td>
<td style="text-align:right;">
311.21
</td>
<td style="text-align:right;">
0.60
</td>
<td style="text-align:right;">
0.49
</td>
<td style="text-align:right;">
-0.89
</td>
</tr>
<tr>
<td style="text-align:right;">
0.20
</td>
<td style="text-align:left;">
1
</td>
<td style="text-align:right;">
337.08
</td>
<td style="text-align:right;">
0.67
</td>
<td style="text-align:right;">
0.79
</td>
<td style="text-align:right;">
-1.24
</td>
<td style="text-align:right;">
0.20
</td>
<td style="text-align:left;">
0
</td>
<td style="text-align:right;">
287.08
</td>
<td style="text-align:right;">
0.67
</td>
<td style="text-align:right;">
0.79
</td>
<td style="text-align:right;">
-1.24
</td>
</tr>
<tr>
<td style="text-align:right;">
0.12
</td>
<td style="text-align:left;">
1
</td>
<td style="text-align:right;">
430.39
</td>
<td style="text-align:right;">
0.41
</td>
<td style="text-align:right;">
0.82
</td>
<td style="text-align:right;">
0.38
</td>
<td style="text-align:right;">
0.12
</td>
<td style="text-align:left;">
0
</td>
<td style="text-align:right;">
380.39
</td>
<td style="text-align:right;">
0.41
</td>
<td style="text-align:right;">
0.82
</td>
<td style="text-align:right;">
0.38
</td>
</tr>
</tbody>
</table>
</div>
<p>As we expect, for all cases where <span class="math inline">\(R=0\)</span>, the counterfactual values for all the variables equal their actual values (a no-rain week in our universe would see no difference in the counterfactual universe where we force it to not rain). Also since the noise variables in the counterfactual universe have the same values as those in ours the subscript &quot;_r&quot; is unnecessary.</p>
<p>Let us compare the causal conditional distribution <span class="math inline">\(P(E | do(R=0))\)</span> with the distribution of the counterfactual energy variable <span class="math inline">\(E_r\)</span> in the above table.</p>
<div class="blue">
<pre class="r"><code>plot(density(df_intervention$E[df_intervention$R == 0]), col=&quot;blue&quot;,
     main = &quot;R = 0&quot;, xlab = &quot;E&quot;)
lines(density(df_counterfactual[[&quot;E_r&quot;]]), col=&quot;red&quot;)</code></pre>
<p><img src="/post/2019-04-13-understanding-pearl-s-front-door-magic_files/figure-html/unnamed-chunk-8-1.png" width="672" /></p>
</div>
<p>Perhaps surprisingly they turn out to be the same. A moment’s reflection about how these two distributions were generated from Sol’s simulator should convince you that the inteventional distribution obtained by causal conditioning is <em>precisely</em> the summary of counterfactuals over all the instances. In fact the interventional distribution <span class="math inline">\(P(E|do(R=r))\)</span> is could more precisely be written as <span class="math inline">\(P(E_r|R_r = r)\)</span>. (Note that this is <strong>non-standard notation</strong> but it makes it easier for me to keep everything straight.)</p>
<p>The notion of counterfactuals is therefore more fundamental than the notion of causal conditioning or interventional distributions. All interventional questions could be answered by generating counterfactual samples, and then appropriately conditioning and aggregating them.</p>
<p>We can ask very general conditional questions about this counterfactual universe. For example, “for a week with low energy production, what is the distribution of the decrease in energy production if we intervened to make it not rain?” Answer: <span class="math inline">\(P(E - E_r|R_r=0, E &lt; e)\)</span>. Filter the above table for <span class="math inline">\(E &lt; e\)</span> and compute the histogram over the difference <span class="math inline">\(E-E_r\)</span> on the remaining rows.</p>
<p>We have been asking counterfactual questions about instances generated from the simulator. What if Sol wanted take a particular week from his dataset and ask what the energy production would have been had it not rained in <em>that week</em>? Since he only has access to the <span class="math inline">\(C\)</span>, <span class="math inline">\(R\)</span> and <span class="math inline">\(E\)</span> variables for that week but <em>not</em> the noise (<span class="math inline">\(U_.\)</span>) variables, he cannot follow our simple procedure of running simulator with arguments do_r=0 and do_uc, do_ur and do_ue set to the particular values. The procedure he needs to follow is to first <em>estimate</em> the <em>posterior distribution</em> over noise variables from the probabilistic model (which the simulator mirrors) conditioned on the observations for that week, and use samples from this posterior as arguments for the simulator. In pseudocode</p>
<div class="blue">
<pre class="r"><code>sample_counterfactual(c, r, e){ ## single week observation = (c, r, e)
  for(i in 1:num_samples) {
    uc, ur, ue = sample_from(P(UC, UR, UE | C=c, R=r, E=e))
    counterfactual_samples_E[i] = generate(1, do_r=0, do_uc=uc, do_ur=ur, do_ue=ue)[[&quot;E&quot;]]
  }
  return(counterfactual_samples_E)
}</code></pre>
</div>
<p>Note that this procedure is no longer one-to-one; for a given week we obtain a <em>distribution</em> over the energy production in the counterfactual “no-rain” universe.</p>
<p>To summarize, the procedure to answer causal questions is to translate it into a description of the variables to <em>fix</em> in the simulator, and of how to filter and aggregate the generated samples. In the happy situation where we have a fully-fledged generative model (and hence a simulator) that can generate joint samples of all the variables in the physical process the preceeding discussion is (almost) the entire story.</p>
</div>
<div id="unhappy-situations" class="section level2">
<h2>Unhappy Situations</h2>
<p>Regrettably we live in a universe where the demand for happiness outstrips supply. If a simulator of the physical process were not available to answer your counterfactuals, what else might be?</p>
<ul>
<li><p><strong>Graph known, data with all variables measured</strong>. This is a situation where you know all the variables that constitute the system, have observations for all of them, and also know the causal structure (the DAG). All you need to produce a simulator is to estimate the <em>functions</em> that compute a variable from its parents (and the variable specific noise) – the so-called <em>mechanisms</em> of the causal model. In a future post I will present an approach for end-to-end learning of all the causal mechanisms of a system.</p></li>
<li><p><strong>Graph known, <em>not</em> all variables measured</strong>. This is where you will need <em>do-calculus</em> – a framework systematized chiefly by the work of Judea Pearl and his students. The calculus enables a <em>completely algorithmisized</em> analysis of the graph and your “do” question to tell you 1) whether your question can be answered from your incomplete data, 2) if it can, <em>produce a formula</em> in terms of your observed variables to answer the question, and 3) if it cannot, specify for which unmeasured variables you will need to collect data to make the question answerable. Please take a moment to recover your composure after this astonishing claim.</p></li>
</ul>
<p>The R package “causaleffect” implements the do-calculus. (There is a similar python package called “dowhy”.) A simple demonstration of the power of the calculus follows.</p>
<div class="blue">
<pre class="r"><code>library(igraph)
library(causaleffect)
g = graph.formula(C -+ R, R -+ E, C -+ E, simplify=F) ## the causal graph
causal.effect(y=&quot;E&quot;, x=&quot;R&quot;, G = g)      ## produce the formula for P(E | do(R))</code></pre>
<pre><code>## [1] &quot;\\sum_{C}P(E|C,R)P(C)&quot;</code></pre>
</div>
<p>Note that this is the same <em>backdoor formula</em> we derived earlier by appealing to specific features of our simulator, which here was produced <em>programmatically</em>.</p>
<ul>
<li><strong>Graph unknown, data with all variables measured</strong>. Estimating the causal structure is much easier if the data can be measured “actively”, that is, by actually intervening in the system that you are studying. This is not a luxury that is available in most circumstances. Several algorithms have been proposed that exploit the Markov independences implied by a causal structure (under another fairly mild assumption called <em>faithfulness</em>) to estimate (the estimable parts of) the causal graph from passively collected data.</li>
<li><strong>Graph unknown, not all variables measured</strong>. Even when not all the variables in the graph are measured certain facts about the causal structure can be inferred from the incomplete data. I do not understand this topic well enough to say more.</li>
<li><strong>Graph unknown, no data</strong>. If you happen to find yourself in this situation, you should probably seek out a Bodhisattva to help with your counterfactual questions.</li>
</ul>
</div>
<div id="references" class="section level2">
<h2>References</h2>
<ol style="list-style-type: decimal">
<li><a href="http://www.michaelnielsen.org/ddi/if-correlation-doesnt-imply-causation-then-what-does/">If correlation doesn’t imply causation, then what does?</a>, by Michael Nielsen. A excellent exposition of the basic concepts of causal calculus. A good place to start for the beginner.</li>
<li><a href="http://bayes.cs.ucla.edu/WHY/">The Book of Why</a>, by Judea Pearl &amp; Dana Mackenzie. You would do well read this book by the father of modern causal reasoning intended for the popular audience.</li>
<li><a href="https://www.stat.cmu.edu/~cshalizi/uADA/12/">Lecture Notes</a>, Cosma Shalizi. This is an excellent resource for slightly more technical material but presented in a very engaging manner, not only about causality but other statistical topics.</li>
</ol>
</div>

</main>

  <footer>
  <footer>
<br /> <br /> <hr> <div class="just-comments" data-apikey="6e288633-d2ef-48b5-ae19-e03c38c46c67"></div>
</footer>

<script async src="https://just-comments.com/w.js"></script>

<script src="//yihui.name/js/math-code.js"></script>
<script async src="//mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script>

<script async src="//yihui.name/js/center-img.js"></script>

  
  <hr/>
  &copy; Harsha Veeramachaneni 2019. Made using  <a href="https://github.com/rstudio/blogdown">blogdown</a> &amp; <a href="https://gohugo.io/">Hugo</a>
  
  </footer>
  </body>
</html>

