<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Simulation View of Causality | Notes To An Earlier Self</title>
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    
  </head>

  <body>
    <nav>
    <ul class="menu">
      
      <li><a href="/">Home</a></li>
      
      <li><a href="/about/">About</a></li>
      
      <li><a href="/categories/">Categories</a></li>
      
      <li><a href="/tags/">Tags</a></li>
      
    </ul>
    <hr/>
    </nav>

<div class="article-meta">
<h1><span class="title">Simulation View of Causality</span></h1>

<h2 class="date">2019/04/13</h2>
</div>

<main>



<style>
div.blue pre.r { background-color:azure; }
div.blue pre { background-color:blue; }
</style>
<p><em>I try to present an intuitive account of causal reasoning and the important notion of causal conditioning without resorting to some of the formalities of the rules of do-calculus, d-separation and the like.</em></p>
<p>First a little background to setup our running example.</p>
<p>The power generated by photovoltaic solar power plants is decreased by not an insignificant when dirt and other particulates collect on the panels. This, so-called <em>soiling</em> problem is especially acute in dusty desert regions which are otherwise ideal sites for solar plants, because the sun shines bright when there arenâ€™t many clouds in sight. Consequently plant operators are always on the lookout for cheap and effective panel soiling mitigation strategies.</p>
<p>Imagine a meticulous solar-scientist Sol who is tasked with estimating the effect on the energy production of weekly washing of the panels in a fleet of solar power plants. Assume that he has at hand data on weekly aggregates of days of rainfall (denoted <span class="math inline">\(R\)</span>), weekly average cloud-cover (denoted <span class="math inline">\(C\)</span>), and total weekly energy production from the solar fleet (denoted <span class="math inline">\(E\)</span>). Sol reasons that if he could estimate the effect of having <em>at least</em> one day rainy day on energy production, he could use it as a proxy for weekly washing.</p>
<p>Before tackling the panel washing problem, Sol analyzes his data builds a <em>generative model</em> for the data generating process. (Recall that a generative model is a story that we believe about a physical process written down in a language of probabilities.)</p>
<p>Sol implements his model as shown below to simulate behaviors or instances of the physical proess (i.e, generate joint samples of <span class="math inline">\((C, R, E)\)</span>).</p>
<div class="blue">
<pre class="r"><code>model &lt;- function(){
  c = runif(1, min=0, max=0.3)                         ## cloud-cover: C ~ Uniform(0, 0.3)
  r = floor(7 *(4*c^2 + runif(1, min=0, max=0.1)))     ## rainy-days: R = f_R(C, noise)
  e = 500 * (1 - 2*c + 0.1 * r) + 10 * rnorm(1)        ## energy: E = f_E(c, r, noise) 
  return(data.frame(C=c, R=r, E=e))
}</code></pre>
</div>
<p>Notice how the average cloudiness (<span class="math inline">\(C\)</span>) is a random variable, rainy days variable (<span class="math inline">\(R\)</span>) is a function of <span class="math inline">\(C\)</span> and noise, and the energy (<span class="math inline">\(E\)</span>) is a function of <span class="math inline">\(C\)</span>, <span class="math inline">\(E\)</span> and different noise The order of computations in the simulator can be depicted as</p>
<p><img src="/post/2019-04-13-understanding-pearl-s-front-door-magic_files/solar_graph.png" style="width:30.0%" /></p>
<p>Sol rewrites his simulator making the noise variables explicit as well as adding some optional arguments to circumvent some of the computations as follows</p>
<div class="blue">
<pre class="r"><code>model &lt;- function(do_c, do_r, do_e, do_uc, do_ur, do_ue){
  uc = ifelse(missing(do_uc), runif(1), do_uc)      # Uc ~ Uniform(0, 1)
  c = ifelse(missing(do_c), uc * 0.3, do_c)          # C = Uc * 0.3 
  
  ur = ifelse(missing(do_ur), runif(1), do_ur)       # Ur ~ Uniform(0, 1)
  r = ifelse(missing(do_r), 
             floor(7 *(4*c^2 + ur * 0.1)), do_r)     # R = f_R(C, Ur)
  
  ue = ifelse(missing(do_ue), rnorm(1), do_ue)       # Ue ~ Normal(0, 1)
  e = ifelse(missing(do_e), 
        500 * (1 - 2*c + 0.1 * r) + 10 * ue,
        do_e)                                        # E = f_E(C, R, Ue)
  
  return(data.frame(C=c, R=r, E=e, Uc=uc, Ur=ur, Ue=ue))
}</code></pre>
</div>
<p>Although the code now looks much more complicated it implements exactly the same model as the version before it, albeit allowing arbitrarily setting the the variables to Sol chooses.</p>
<p><img src="/post/2019-04-13-understanding-pearl-s-front-door-magic_files/solar_graph_noise.png" style="width:30.0%" /></p>

</main>

  <footer>
  <footer>
<br /> <br /> <hr> <div class="just-comments" data-apikey="6e288633-d2ef-48b5-ae19-e03c38c46c67"></div>
</footer>

<script async src="https://just-comments.com/w.js"></script>

<script src="//yihui.name/js/math-code.js"></script>
<script async src="//mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script>

<script async src="//yihui.name/js/center-img.js"></script>

  
  <hr/>
  &copy; Harsha Veeramachaneni 2019. Made using  <a href="https://github.com/rstudio/blogdown">blogdown</a> &amp; <a href="https://gohugo.io/">Hugo</a>
  
  </footer>
  </body>
</html>

