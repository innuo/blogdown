<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Extrapolating by Inverse Optimization | Notes To An Earlier Self</title>
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    
  </head>

  <body>
    <nav>
    <ul class="menu">
      
      <li><a href="/">Home</a></li>
      
      <li><a href="/about/">About</a></li>
      
      <li><a href="/categories/">Categories</a></li>
      
      <li><a href="/tags/">Tags</a></li>
      
    </ul>
    <hr/>
    </nav>

<div class="article-meta">
<h1><span class="title">Extrapolating by Inverse Optimization</span></h1>

<h2 class="date">2019/03/09</h2>
</div>

<main>



<p><em>Wherein I present a simple example of a prediction problem modeled as inverse optimization, with a brief detour into Bayesian estimation.</em></p>
<p>Our story begins with Alice who runs a grocery store with a small selection of locally grown produce. Alice wishes to estimate the impacts of changing the prices of her produce on the purchase behavior of her customers and wonders if the data she has been collecting over the previous year can help. After consulting with her data scientist friend she puts together a database of quantities of produce purchased by individual customers under various pricing regimes, and hands him the trove.</p>
<p>The collected data looks something like the following. (In each row the prices and quantities are for <em>all</em> the products Alice sells.)</p>
<table>
<thead>
<tr class="header">
<th align="left">Date</th>
<th align="left">Customer.ID</th>
<th align="left">Price.Vector</th>
<th align="left">Quantity.Vector</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Jan 1</td>
<td align="left">XYZ</td>
<td align="left">[$3.2, $2.5, $1.0, …]</td>
<td align="left">[1 lb, 0.0 lb, 0.0 lb, …]</td>
</tr>
<tr class="even">
<td align="left">Jan 8</td>
<td align="left">ABC</td>
<td align="left">[$2.0, $2.0, $1.5, …]</td>
<td align="left">[0.0 lb, 0.0 lb, 0.5 lb, …]</td>
</tr>
<tr class="odd">
<td align="left">Feb 4</td>
<td align="left">XYZ</td>
<td align="left">[$2.5, $2.0, $1.8, …]</td>
<td align="left">[1.0 lb, 0.0 lb, 0.1 lb, …]</td>
</tr>
<tr class="even">
<td align="left">…</td>
<td align="left">…</td>
<td align="left">…</td>
<td align="left">…</td>
</tr>
</tbody>
</table>
<p>The data scientist friend doesn’t see what the big problem is. He builds deep learning models in his sleep and this seems like a simple regression problem. He could just build a machine to predict the quantities column from the price column and take the afternoon off.</p>
<p>Alas it was not to be; the price vectors that Alice wants to plug into the trained regression model are well outside the ranges of those that she provided the data scientist for training. She does not see the point of any such modeling if it doesn’t enable extrapolation. She is appalled by the resulting nonsensical predictions, that her friend assures her were produced by algorithms indistinguishable from the ones that in the near future will drive her around town.</p>
<div id="a-physics-of-purchase-behavior" class="section level2">
<h2>A Physics of Purchase Behavior</h2>
<p>Alice decides to take a less shallow approach and write out what she knows about the problem and how it relates to what she wishes to estimate.</p>
<p>She reasons that each of her customers <span class="math inline">\(\smash{c_i}\)</span> has a weekly budget <span class="math inline">\(\smash{b_{i}}\)</span> for produce (<span class="math inline">\(\smash{t}\)</span> stands for the date of the store visit) and a personal produce value vector <span class="math inline">\(\smash{v_i}\)</span>. (She makes the simplifying asssumption that the budget does not vary from week to week.) Each customer may have other individual constraints on the purchases (e.g., at least <span class="math inline">\(3\)</span> lb of fruit, no more than <span class="math inline">\(2\)</span> lb of perishables.)</p>
<p>She hypothesizes that a customer on every weekly visit looks at the produce price vector <span class="math inline">\(\smash{p_t}\)</span>, and mentally runs a simple optimization of the following form to decide what quantities of each item of produce (<span class="math inline">\(x_{it}\)</span>) he will purchase:</p>
<p><span class="math display">\[\begin{aligned}
x_{it} &amp;= \mbox{arg max}_x \; v_i^T x \\
\mbox{subject to} &amp;\;\; \smash{p_t^T} x \leq b_{i} \\
&amp;\; \; A x \leq d_i
\end{aligned}
\]</span></p>
<p>The last constraint captures the notion of the customer-specific constraints mentioned above, where <span class="math inline">\(A\)</span> is assumed known (since its rows define common purchase constraints) while the constraint bounds <span class="math inline">\(d_i\)</span> are not known.</p>
<p>The above optimization problem with a linear objective and constraints is called a <em>Linear Program</em> for which there exist very efficient solvers. For a basic implementation of a linear program in R see Appendix below.</p>
<p>That is, if for any customer Alice knew the parameters of <em>their</em> optimization problem (<span class="math inline">\(v_i\)</span> up to a normalizing scalar, <span class="math inline">\(b_i\)</span> and <span class="math inline">\(d_i\)</span>) then predicting the purchase behavior is easy. It just involves solving the above problem for any price vector of interest <span class="math inline">\(p\)</span> to obtain a prediction of that customer’s purchase quantity vector <span class="math inline">\(x_i\)</span>. Note that, albeit esoteric, the optimizer defines a family of regression functions <span class="math inline">\(x_i = Opt(p_t; \theta)\)</span> parameterized by <span class="math inline">\(\theta \triangleq (v_i, b_i, d_i)\)</span>, in principle, no different from any other family.</p>
<p>Therefore the problem of <em>learning</em> the regressor reduces to estimating these parameters from historical prices and their associated quantity vectors. This estimation problem, because it is posed as <em>inverting</em> the optimization procedure, is studied under the heading <em>Inverse Optimization</em>.</p>
<p>(The term engineers use for this <em>inverting</em> process, that is, estimating the parameters of a system from observations, is <em>System Identification</em>. Although many of the techniques that engineers use exploit some special structure of their systems, their <em>task</em> is exactly the same as Alice’s.)</p>
</div>
<div id="bayesianism-as-commonsense" class="section level2">
<h2>Bayesianism as Commonsense</h2>
<p>Alice first codes up the <span class="math inline">\(Opt(.)\)</span> function in the hope that when she comes up with a way to estimate the parameters, she would be ready with the prediction function. She quickly realizes that a simple approach to estimate the parameters is the following. First select some sensible ranges for the various parameters (knowing the neighborhood well she has a good sense of what reasonable budgets, value vectors etc.), sample a vector of parameters within that range and run the function <span class="math inline">\(Opt(.)\)</span> over the prices in her dataset. If the resulting quantity predictions are <em>close</em> to those in the data, keep the parameter vector, else discard it. We can view this procedure as sampling, followed by running the <span class="math inline">\(Opt(.)\)</span> regression function (which I will call <em>simulation</em>, because it simulates the purchase behavior), followed by filtering the samples that do not yield data close to the historical record (the observations).</p>
<p>After running this <em>sample-simulate-filter</em> process on a large number of samples she will have a set of parameter vectors which produced data that looks like her database, that is, a set of parameter vectors <em>compatible</em> with her data. If this set ends up being clustered around some value (i.e., if <em>very</em> different parameter settings do not end up producing data close to the observations), then she could choose the mean of the filtered parameter set as her estimate. Problem solved.</p>
<p>In fact, she reasons, that instead of taking the mean of the filtered parameter vectors, she could use them to estimate her uncertainty in the predictions from her regression function. For a price vector that she would like to plug into her regression function, she could run the <span class="math inline">\(Opt(.)\)</span> function over a sample of compatible parameter vectors and use the range of the predicted values as her measure of uncertainty.</p>
<p>Although Alice is unware of it, she not only independently derived the fundaments of Bayesian reasoning from commonsense, but a particular <em>computational</em> approach to Bayesian estimation. An entire subfield of Bayesian statistics called <em>Approximate Bayesian Computation (ABC)</em> is dedicated to Alice’s sample-simulate-filter method, with the goal of making it computationally feasible. Note how the <em>ABC</em> approach can be applied to invert any parameterized simulator, at least in principle. This generality is paid for in computational costs.</p>
<p><strong>A Quick Aside on Identifiability</strong>. <em>Identifiability</em> is a topic that statisticians like to obsess over in their work, resulting in a thicket of abstruse procedures for practitioners to follow to avoid a dull feeling of being insufficiently diligent.</p>
<p>From a Bayesian vantage the commonsense way to think about identifiability is captured in a statement made above – <em>very</em> different parameter settings do not end up producing data close to the observations. In fact, it is even a bit milder than that. Loosely speaking, for the kinds of extrapolations we wish to perform with the learned model (i.e, simulator + compatible parameter vectors), if the predictions on any input from <em>most</em> of the compatible parameter vectors are <em>similar</em>, then for practical purposes the model is identified.</p>
<p>Identifiability in a Bayesian setting is a function of the prior, the simulator, and the observed data. If we can disallow parts of the parameter space which end up being compatible with the data by some external considerations, or if we are able to collect more of the right kind of data, we can recover idenfitiability. If neither is possible, the only hope is to restrict the simulator by reparameterization and only gain partial knowledge about the system being studied.</p>
</div>
<div id="saving-on-aws-costs" class="section level2">
<h2>Saving on AWS Costs</h2>
<p>As I alluded to above, the ABC procedure can be very computionally demanding when the amount of observed data or the number of parameters is large. Consequently for models (priors + simulators) for which we can know a little bit more, statisticians and engineers have come up with a host of techniques to speed up the estimation process. For example, if the simulation function is such that we can compute the <em>likelihood</em>, that is, the probability of the observations for a given parameter vector, techniques like Markov-Chain Monte Carlo (MCMC) or Variational Bayes can exploit that fact for a speedy estimation of the model posterior (which is a specification of the parameter vectors compatible with the observed data.) I won’t go any more into these techniques here than pointing to <a href="https://mlstatold.blogspot.com/2018/05/a-short-presentation-on-probabilistic.html">my presentation</a> on variational inference.</p>
</div>
<div id="finally-getting-to-the-point" class="section level2">
<h2>Finally Getting to the Point</h2>
<p>It turns out that for the particular model that Alice constructed by representing the purchase quantities as solutions of linear programs, the parameters of the model can be estimated by exploiting optimality properties of linear programs.</p>
<p>For simplicity let us assume that the measure of distance of the predictions from the simulator to the observed data is the sum of squared errors. We can now restate Alice’s parameter estimation problem as</p>
<p><span class="math display">\[\begin{aligned}
\hat{\theta}_i \triangleq  (\hat{v}_i, \hat{b}_i, \hat{d}_i) &amp;= \mbox{arg min}_\theta \;\sum_t{(x_{it} - q_{it})^2} \\
\mbox{subject to} &amp;\;\; x_{it} = Opt(p_t, \theta) 
\end{aligned}
\]</span> where <span class="math inline">\(p_t\)</span> is the price for week <span class="math inline">\(t\)</span> and <span class="math inline">\(q_{it}\)</span> is the quanty vector purchased by customer <span class="math inline">\(i\)</span> that week.</p>
<p>Again, the above optimization problem is to minimize the squared error between the predictions <span class="math inline">\(x_{it}\)</span> of the simulator and the observed quantities <span class="math inline">\(q_{it}\)</span> over the parameter vector <span class="math inline">\(\theta_i\)</span>. The solution of this problem will yield the estimate the parameter vector for customer <span class="math inline">\(i\)</span>.</p>
<p>(Like in the discussion above if we have prior knowledge about reasonable values for the parameters or on how the parameters vary between customers, we can use this knowledge by adding cost terms into the objective. Note that this way of adding cost terms into the objective to represent prior knowledge and then minimizing the overall cost for a point estimate of the parameters is called <em>Maximum A Posteriori</em> estimation in Bayesian lingo.)</p>
<p>When we look at the optimization problem above, we notice that it is a <em>nested</em> optimization problem, because the <span class="math inline">\(Opt(.)\)</span> function is itself a linear program and is consequently a special case of what is called a <em>bilevel</em> optimization problem.</p>
</div>
<div id="appendix" class="section level2">
<h2>Appendix:</h2>
<p>Example R code on which to base Alice’s <span class="math inline">\(Opt(.)\)</span> function.</p>
<pre class="r"><code>library(CVXR)

x &lt;- Variable(2) #only two products 
v &lt;- c(0.1, 0.9) #value vector
value &lt;- sum(v * x) #total value that the customer optimizes

p &lt;- c(3, 2)  #prices of the two products
constr_budget &lt;- sum(p * x) &lt;= 10 #budget no more than $10

A &lt;- rbind(c(1, 0), c(0, 1))
b &lt;- c(2, 4)
constr_other &lt;- A %*% x &lt;= b #other constraints

solution &lt;- solve(Problem(Maximize(value), list(constr_budget, constr_other))) #solve for value maximization

cat(paste0(&#39;Status: &#39;, solution$status))
## Status: optimal
cat(paste0(round(solution$getValue(x), 2))) #print optimal quantity vector
## 0.67 4</code></pre>
</div>

</main>

  <footer>
  <footer>
<br /> <br /> <hr> <div class="just-comments" data-apikey="6e288633-d2ef-48b5-ae19-e03c38c46c67"></div>
</footer>

<script async src="https://just-comments.com/w.js"></script>

<script src="//yihui.name/js/math-code.js"></script>
<script async src="//mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script>

<script async src="//yihui.name/js/center-img.js"></script>

  
  <hr/>
  &copy; Harsha Veeramachaneni 2019 <a href="https://github.com/rstudio/blogdown">blogdown</a> &amp; <a href="https://gohugo.io/">Hugo</a>
  
  </footer>
  </body>
</html>

